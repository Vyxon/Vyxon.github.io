import { Env, ENV } from '../components/env';
export var API_AUTH_TYPE;
(function (API_AUTH_TYPE) {
    API_AUTH_TYPE[API_AUTH_TYPE["PUBLIC_KEY"] = 0] = "PUBLIC_KEY";
    API_AUTH_TYPE[API_AUTH_TYPE["TOKEN"] = 1] = "TOKEN";
})(API_AUTH_TYPE || (API_AUTH_TYPE = {}));
export class ApiBase {
    constructor(auth, authType) {
        this.auth = auth;
        this.authType = authType || API_AUTH_TYPE.PUBLIC_KEY;
        this.env = new Env([
            { env: ENV.SANDBOX, url: 'https://api-sandbox.' },
            { env: ENV.PROD, url: 'https://api.' },
            { env: ENV.STAGING, url: 'https://apista.' },
            { env: ENV.STAGING_2, url: 'https://apista-2.' },
            { env: ENV.STAGING_3, url: 'https://apista-3.' },
            { env: ENV.STAGING_4, url: 'https://apista-4.' },
            { env: ENV.STAGING_5, url: 'https://apista-5.' },
        ]);
    }
    /**
     * Current method can change environment. By default environment = sandbox.
     * Also we can change domain alias for this environment. By default domain_alias = paydock.com
     *
     * @example
     * widget.setEnv('production');
     * @param {string} env - sandbox, production
     * @param {string} [alias] - Own domain alias
     */
    setEnv(env, alias) {
        this.env.setEnv(env, alias);
        return this;
    }
    getClient(method, link) {
        let request = new XMLHttpRequest();
        request.open(method, this.env.getConf().url + link, true);
        request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        this.setAuthHeader(request);
        return {
            config: request,
            send: (body, cb, errorCb) => {
                request.onload = () => this.parser({ text: request.responseText, status: request.status }, cb, errorCb);
                request.send(JSON.stringify(body));
            },
        };
    }
    getClientPromise(method, link) {
        let request = new XMLHttpRequest();
        request.open(method, this.env.getConf().url + link, true);
        request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        this.setAuthHeader(request);
        return {
            config: request,
            send: (body) => new Promise((resolve, reject) => {
                request.onload = () => resolve({ text: request.responseText, status: request.status });
                request.send(JSON.stringify(body));
            }).then((value) => this.parserPromise(value)),
        };
    }
    parser({ text, status }, cb, errorCb) {
        try {
            let res = JSON.parse(text);
            if ((status >= 200 && status < 300) || status === 302)
                return cb(res.resource.data);
            else
                errorCb(res.error || { message: 'unknown error' });
        }
        catch (e) {
        }
    }
    parserPromise({ text, status }) {
        try {
            const res = JSON.parse(text);
            return ((status >= 200 && status < 300) || status === 302)
                ? Promise.resolve(res.resource.data)
                : Promise.reject(res.error || { message: 'unknown error' });
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    setAuthHeader(request) {
        switch (this.authType) {
            case API_AUTH_TYPE.PUBLIC_KEY: {
                request.setRequestHeader('x-user-public-key', this.auth);
                break;
            }
            case API_AUTH_TYPE.TOKEN: {
                request.setRequestHeader('x-access-token', this.auth);
                break;
            }
        }
    }
}
//# sourceMappingURL=../../src/lib/api/api-base.js.map