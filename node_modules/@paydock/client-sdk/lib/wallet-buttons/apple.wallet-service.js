import { WALLET_TYPE } from "../components/param";
import { WalletService, WALLET_EVENT, } from "./wallet-service";
;
export class AppleWalletService extends WalletService {
    constructor(publicKey, meta, gatewayName, eventEmitter) {
        super(publicKey, meta);
        this.gatewayName = gatewayName;
        this.eventEmitter = eventEmitter;
        this.latestShippingData = {};
        this.onValidateMerchant = (event) => {
            this.getMerchantSession()
                .then((merchantSession) => {
                this.paymentSession.completeMerchantValidation(merchantSession);
            })
                .catch((err) => console.error("Error fetching merchant session", err));
        };
        this.onPaymentAuthorized = (event) => {
            var _a;
            const { token, billingContact, shippingContact } = event.payment;
            this.latestShippingData.shippingContact = shippingContact;
            const shippingOptionMethod = (_a = this.selectedShippingOption) === null || _a === void 0 ? void 0 : _a.type;
            this.eventEmitter.emit(WALLET_EVENT.PAYMENT_METHOD_SELECTED, {
                data: Object.assign({ customer: {
                        payment_source: {
                            wallet_type: WALLET_TYPE.APPLE,
                            card_name: token.paymentMethod.displayName,
                            type: token.paymentMethod.type,
                            card_scheme: token.paymentMethod.network,
                            address_line1: billingContact === null || billingContact === void 0 ? void 0 : billingContact.addressLines[0],
                            address_line2: billingContact === null || billingContact === void 0 ? void 0 : billingContact.addressLines[1],
                            address_country: billingContact === null || billingContact === void 0 ? void 0 : billingContact.countryCode,
                            address_city: billingContact === null || billingContact === void 0 ? void 0 : billingContact.locality,
                            address_postcode: billingContact === null || billingContact === void 0 ? void 0 : billingContact.postalCode,
                            address_state: billingContact === null || billingContact === void 0 ? void 0 : billingContact.administrativeArea,
                            ref_token: token.paymentData ? JSON.stringify(token.paymentData) : '',
                        },
                    } }, (this.meta.request_shipping && shippingContact) && {
                    shipping: Object.assign(Object.assign(Object.assign({}, (shippingOptionMethod && { method: shippingOptionMethod })), (this.hasShippingOptions() && { options: this.meta.shipping_options })), { address_line1: shippingContact.addressLines[0], address_line2: shippingContact.addressLines[1], address_country: shippingContact.countryCode, address_city: shippingContact.locality, address_postcode: shippingContact.postalCode, address_state: shippingContact.administrativeArea, contact: {
                            first_name: shippingContact.givenName,
                            last_name: shippingContact.familyName,
                            email: shippingContact.emailAddress,
                            phone: shippingContact.phoneNumber,
                        } }),
                }),
                onSuccess: () => this.paymentSession.completePayment(ApplePaySession.STATUS_SUCCESS),
                onError: () => this.paymentSession.completePayment(ApplePaySession.STATUS_FAILURE),
            });
        };
        this.onShippingContactSelected = (event) => {
            this.latestShippingData.shippingContact = event.shippingContact;
            const parsedCallbackData = this.parseUpdateData(this.latestShippingData);
            this.eventEmitter.emit(WALLET_EVENT.UPDATE, parsedCallbackData);
            return new Promise((res, rej) => {
                this.latestShippingChangePromiseResolve = res;
                this.latestShippingChangePromiseReject = rej;
            });
        };
        this.onShippingMethodSelected = (event) => {
            var _a, _b;
            this.latestShippingData.shippingMethod = event.shippingMethod;
            const update = {
                newTotal: {
                    label: this.meta.amount_label || ((_b = (_a = this.getMetaRawDataInitialization()) === null || _a === void 0 ? void 0 : _a.total) === null || _b === void 0 ? void 0 : _b.label),
                    amount: this.meta.amount.toString(),
                    type: "final",
                },
            };
            this.paymentSession.completeShippingMethodSelection(update);
        };
        this.parseUpdateData = (data) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            // From Apple docs (https://developer.apple.com/documentation/apple_pay_on_the_web/applepaypayment/1916097-shippingcontact):
            // Before the user authorizes the transaction with Touch ID, Face ID, or passcode, you receive redacted address information
            return Object.assign({ shipping: {
                    address_city: (_a = data === null || data === void 0 ? void 0 : data.shippingContact) === null || _a === void 0 ? void 0 : _a.locality,
                    address_state: (_b = data === null || data === void 0 ? void 0 : data.shippingContact) === null || _b === void 0 ? void 0 : _b.administrativeArea,
                    address_postcode: (_c = data === null || data === void 0 ? void 0 : data.shippingContact) === null || _c === void 0 ? void 0 : _c.postalCode,
                    address_country: (_d = data === null || data === void 0 ? void 0 : data.shippingContact) === null || _d === void 0 ? void 0 : _d.countryCode,
                } }, (data === null || data === void 0 ? void 0 : data.shippingMethod) && {
                selected_shipping_option: {
                    id: (_e = data === null || data === void 0 ? void 0 : data.shippingMethod) === null || _e === void 0 ? void 0 : _e.identifier,
                    label: (_f = data === null || data === void 0 ? void 0 : data.shippingMethod) === null || _f === void 0 ? void 0 : _f.label,
                    detail: (_g = data === null || data === void 0 ? void 0 : data.shippingMethod) === null || _g === void 0 ? void 0 : _g.detail,
                    amount: (_h = data === null || data === void 0 ? void 0 : data.shippingMethod) === null || _h === void 0 ? void 0 : _h.amount,
                },
            });
        };
        this.formatShippingOptions = (shipping_options) => shipping_options.map((o) => ({
            identifier: o.id,
            label: o.label,
            detail: (o === null || o === void 0 ? void 0 : o.detail) || '',
            amount: o.amount,
        }));
        this.eventEmitter = eventEmitter;
    }
    getGatewayName() {
        return this.gatewayName;
    }
    getMerchantId() {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.meta) === null || _a === void 0 ? void 0 : _a.credentials) === null || _b === void 0 ? void 0 : _b[WALLET_TYPE.APPLE]) === null || _c === void 0 ? void 0 : _c.merchant) || '';
    }
    ;
    getMetaStyles() {
        var _a, _b, _c;
        if (((_a = this.meta) === null || _a === void 0 ? void 0 : _a.style) && typeof ((_b = this.meta) === null || _b === void 0 ? void 0 : _b.style) === 'object') {
            const metaStyles = JSON.parse(JSON.stringify((_c = this.meta) === null || _c === void 0 ? void 0 : _c.style));
            if ('google' in metaStyles)
                metaStyles === null || metaStyles === void 0 ? true : delete metaStyles.google; // to offer backward compatibility
            if ('apple' in metaStyles)
                return metaStyles === null || metaStyles === void 0 ? void 0 : metaStyles.apple;
            else
                return metaStyles; // to offer backward compatibility
        }
        else {
            return null;
        }
    }
    getMetaRawDataInitialization() {
        var _a, _b, _c, _d;
        if (((_a = this.meta) === null || _a === void 0 ? void 0 : _a.raw_data_initialization) && ((_b = this.meta) === null || _b === void 0 ? void 0 : _b.raw_data_initialization) && typeof ((_c = this.meta) === null || _c === void 0 ? void 0 : _c.raw_data_initialization) === 'object') {
            const metaRawDataInit = JSON.parse(JSON.stringify((_d = this.meta) === null || _d === void 0 ? void 0 : _d.raw_data_initialization));
            if ('google' in metaRawDataInit)
                metaRawDataInit === null || metaRawDataInit === void 0 ? true : delete metaRawDataInit.google; // to offer backward compatibility
            if ('apple' in metaRawDataInit)
                return metaRawDataInit === null || metaRawDataInit === void 0 ? void 0 : metaRawDataInit.apple;
            else
                return metaRawDataInit; // to offer backward compatibility
        }
        else {
            return null;
        }
    }
    isShippingRequired() {
        var _a;
        return (_a = this.meta) === null || _a === void 0 ? void 0 : _a.request_shipping;
    }
    hasShippingOptions() {
        var _a, _b;
        return ((_a = this.meta) === null || _a === void 0 ? void 0 : _a.request_shipping) && !!((_b = this.meta) === null || _b === void 0 ? void 0 : _b.shipping_options);
    }
    load(container) {
        if (!window.Promise) {
            // Given that this library does not rely in any polyfill for promises, and this integration depends on them, we early return if Promises are not supported for the browser (like I.E. 11).
            this.eventEmitter.emit(WALLET_EVENT.UNAVAILABLE, { wallet: WALLET_TYPE.APPLE });
            return;
        }
        return this.checkAvailability()
            .then((available) => {
            var _a;
            if (!available) {
                this.eventEmitter.emit(WALLET_EVENT.UNAVAILABLE, { wallet: WALLET_TYPE.APPLE });
                return;
            }
            // Store default shipping option
            if (this.isShippingRequired() && this.hasShippingOptions()) {
                this.selectedShippingOption = (_a = this.meta) === null || _a === void 0 ? void 0 : _a.shipping_options[0];
                this.latestShippingData.shippingMethod = this.formatShippingOptions([this.selectedShippingOption])[0];
            }
            this.mount(container);
        })
            .catch((err) => console.error("Error checking ApplePay availability", err));
    }
    update(data) {
        var _a, _b, _c;
        if (!this.latestShippingChangePromiseResolve || !this.latestShippingChangePromiseReject)
            return;
        if (!data.success || !data.body)
            return this.latestShippingChangePromiseReject(); // TODO: check how to handle Error messages from Merchant at update() callback response
        const newAmount = (_a = data === null || data === void 0 ? void 0 : data.body) === null || _a === void 0 ? void 0 : _a.amount;
        const newShippingOptions = (_b = data === null || data === void 0 ? void 0 : data.body) === null || _b === void 0 ? void 0 : _b.shipping_options;
        if (newAmount)
            this.meta.amount = newAmount;
        if (newShippingOptions) {
            this.meta.shipping_options = newShippingOptions;
            this.selectedShippingOption = newShippingOptions ? newShippingOptions[0] : undefined;
        }
        const update = Object.assign({ newTotal: {
                label: (_c = this.meta) === null || _c === void 0 ? void 0 : _c.amount_label,
                amount: this.meta.amount.toString(),
                type: "final",
            } }, (this.isShippingRequired() && this.hasShippingOptions()) && {
            newShippingMethods: this.formatShippingOptions(this.meta.shipping_options),
        });
        this.paymentSession.completeShippingContactSelection(update);
        this.latestShippingChangePromiseResolve({});
    }
    checkAvailability() {
        return new Promise((resolve, _reject) => {
            if (!window.ApplePaySession || !ApplePaySession) {
                resolve(false);
            }
            ApplePaySession.canMakePaymentsWithActiveCard(this.getMerchantId())
                .then((available) => resolve(available))
                .catch((_err) => resolve(false));
        });
    }
    mount(container) {
        const style = document.createElement('style');
        style.innerHTML = this.createButtonStyle();
        document.head.appendChild(style);
        const button = document.createElement('div');
        button.onclick = () => this.onApplePayButtonClicked();
        button.classList.add('paydock-apple-container', 'apple-pay-button', 'apple-pay-button-black');
        container.getElement().appendChild(button);
    }
    onApplePayButtonClicked() {
        this.paymentSession = new ApplePaySession(3, this.createRequest());
        this.paymentSession.onvalidatemerchant = this.onValidateMerchant;
        this.paymentSession.onpaymentauthorized = this.onPaymentAuthorized;
        this.paymentSession.onshippingcontactselected = this.onShippingContactSelected;
        this.paymentSession.onshippingmethodselected = this.onShippingMethodSelected;
        this.paymentSession.begin();
    }
    createRequest() {
        // In case Merchants decide to use other values they should provide all ApplePayPaymentRequest fields at "meta.raw_data_initialization".
        // https://developer.apple.com/documentation/apple_pay_on_the_web/applepaypaymentrequest
        var _a;
        const rawDataInitialization = this.getMetaRawDataInitialization();
        if (rawDataInitialization && typeof rawDataInitialization === 'object') {
            if (typeof rawDataInitialization.total === 'object')
                rawDataInitialization.total.amount = this.meta.amount.toString();
            else
                rawDataInitialization.total = { label: ((_a = this.meta) === null || _a === void 0 ? void 0 : _a.amount_label) || '', amount: this.meta.amount.toString() };
            if (this.isShippingRequired() && this.hasShippingOptions())
                rawDataInitialization.shippingMethods = this.formatShippingOptions(this.meta.shipping_options);
        }
        return rawDataInitialization || Object.assign(Object.assign(Object.assign({ countryCode: this.meta.country.toUpperCase(), currencyCode: this.meta.currency.toUpperCase(), merchantCapabilities: ["supports3DS", "supportsCredit", "supportsDebit"], supportedNetworks: ["visa", "masterCard", "amex", "discover"] }, (this.meta.show_billing_address && { requiredBillingContactFields: ["name", "postalAddress"] })), (this.isShippingRequired() && Object.assign({ requiredShippingContactFields: ["postalAddress", "name", "phone", "email"] }, (this.hasShippingOptions() && {
            shippingMethods: this.formatShippingOptions(this.meta.shipping_options),
        })))), { total: {
                label: this.meta.amount_label,
                amount: this.meta.amount.toString(),
                type: "final",
            } });
    }
    getMerchantSession() {
        return new Promise((resolve, reject) => this.eventEmitter.emit(WALLET_EVENT.CALLBACK, {
            data: Object.assign({ request_type: "CREATE_SESSION", wallet_type: WALLET_TYPE.APPLE, session_id: window.location.hostname }, this.isShippingRequired() && { request_shipping: this.meta.request_shipping }),
            onSuccess: (res) => resolve(res),
            onError: (message) => reject(message),
        }));
    }
    ;
    createButtonStyle() {
        var _a, _b;
        return `
            .paydock-apple-container {
                width: 100%;
                height: 40px;
            }

            @supports (-webkit-appearance: -apple-pay-button) {
                .apple-pay-button {
                    display: inline-block;
                    -webkit-appearance: -apple-pay-button;
                    -apple-pay-button-type: ${((_a = this.getMetaStyles()) === null || _a === void 0 ? void 0 : _a.button_type) || 'plain'}
                }
                .apple-pay-button-black {
                    -apple-pay-button-style: black;
                }
                .apple-pay-button-white {
                    -apple-pay-button-style: white;
                }
                .apple-pay-button-white-with-line {
                    -apple-pay-button-style: white-outline;
                }
            }

            @supports not (-webkit-appearance: -apple-pay-button) {
                .apple-pay-button {
                    display: inline-block;
                    background-size: 100% 60%;
                    background-repeat: no-repeat;
                    background-position: 50% 50%;
                    border-radius: 5px;
                    padding: 0px;
                    box-sizing: border-box;
                    min-width: 200px;
                    min-height: 32px;
                    max-height: 64px;
                    -apple-pay-button-type: ${((_b = this.getMetaStyles()) === null || _b === void 0 ? void 0 : _b.button_type) || 'plain'}
                }
                .apple-pay-button-black {
                    background-image: -webkit-named-image(apple-pay-logo-white);
                    background-color: black;
                }
                .apple-pay-button-white {
                    background-image: -webkit-named-image(apple-pay-logo-black);
                    background-color: white;
                }
                .apple-pay-button-white-with-line {
                    background-image: -webkit-named-image(apple-pay-logo-black);
                    background-color: white;
                    border: .5px solid black;
                }
            }
        `;
    }
}
//# sourceMappingURL=../../src/lib/wallet-buttons/apple.wallet-service.js.map