import { WalletService, WALLET_EVENT, } from "./wallet-service";
export class PaypalWalletService extends WalletService {
    load(container) {
        if (!window.Promise) {
            // Given that this library does not rely in any polyfill for promises, and this integration depends on them, we early return if Promises are not supported for the browser (like I.E. 11).
            this.eventEmitter.emit(WALLET_EVENT.UNAVAILABLE, null);
            return;
        }
        const buttonId = container.getElement().id || '';
        const paypalScript = document.createElement("script");
        paypalScript.src = `https://www.paypal.com/sdk/js?client-id=${this.publicKey}&currency=${this.meta.currency}${(this.meta.pay_later === true) ? '&enable-funding=paylater&disable-funding=card' : `&disable-funding=credit,card`}${!this.meta.capture ? `&intent=authorize` : ''}`;
        paypalScript.async = true;
        paypalScript.onload = () => {
            if (window.paypal) {
                this.paypal = window.paypal;
                this.paypal.Buttons(Object.assign(Object.assign({}, (this.meta.style && { style: this.meta.style })), { createOrder: () => new Promise((resolve, reject) => {
                        this.eventEmitter.emit(WALLET_EVENT.CALLBACK, {
                            data: Object.assign({ request_type: "CREATE_TRANSACTION" }, this.meta.request_shipping && { request_shipping: this.meta.request_shipping }),
                            onSuccess: (res) => resolve(res.id),
                            onError: (err) => reject(err),
                        });
                    }), onShippingChange: (data, _actions) => new Promise((resolve, reject) => {
                        const parsedCallbackData = this.parseUpdateData(data);
                        this.latestShippingData = parsedCallbackData.shipping;
                        this.latestShippingChangePromiseResolve = resolve;
                        this.latestShippingChangePromiseReject = reject;
                        this.eventEmitter.emit(WALLET_EVENT.UPDATE, parsedCallbackData);
                    }), onApprove: (data) => new Promise((resolve, reject) => this.eventEmitter.emit(WALLET_EVENT.PAYMENT_METHOD_SELECTED, {
                        data: { payment_method_id: data.orderID, customer: { payment_source: { external_payer_id: data.payerID } } },
                        onSuccess: () => resolve(true),
                        onError: (err) => reject(err),
                    })), onError: (err) => {
                        // Error handling so that paypal does not throw an uncaught error
                        // We're already handling errors and notifying Merchants at "wallet-buttons.ts"
                    } })).render(`#${buttonId}`);
            }
            else {
                this.eventEmitter.emit(WALLET_EVENT.UNAVAILABLE, null);
            }
            ;
        };
        document.head.appendChild(paypalScript);
        return;
    }
    update(data) {
        if (!this.latestShippingChangePromiseResolve || !this.latestShippingChangePromiseReject)
            return;
        if (!data.success)
            return this.latestShippingChangePromiseReject();
        this.eventEmitter.emit(WALLET_EVENT.CALLBACK, {
            data: { request_type: "UPDATE_TRANSACTION", shipping: this.latestShippingData },
            onSuccess: (_res) => this.latestShippingChangePromiseResolve(true),
            onError: () => this.latestShippingChangePromiseReject(),
        });
    }
    parseUpdateData(data) {
        var _a;
        return Object.assign(Object.assign({ wallet_order_id: data.orderID, wallet_session_id: data.paymentID, payment_source: {
                wallet_payment_method_id: data.paymentToken,
            } }, data.shipping_address && {
            shipping: {
                address_city: data.shipping_address.city,
                address_state: data.shipping_address.state,
                address_postcode: data.shipping_address.postal_code,
                address_country: data.shipping_address.country_code,
            },
        }), data.selected_shipping_option && {
            selected_shipping_option: {
                id: data.selected_shipping_option.id,
                label: data.selected_shipping_option.label,
                amount: data.selected_shipping_option.amount.value,
                currency: data.selected_shipping_option.amount.currency_code,
                type: (_a = data.selected_shipping_option) === null || _a === void 0 ? void 0 : _a.type,
            },
        });
    }
}
//# sourceMappingURL=../../src/lib/wallet-buttons/paypal.wallet-service.js.map