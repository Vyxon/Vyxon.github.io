import { Container } from "../components/container";
import { WALLET_GATEWAY } from "../components/param";
import { FlypayWalletService } from './flypay.wallet-service';
import { PaypalWalletService } from "./paypal.wallet-service";
import { StripeWalletService } from "./stripe.wallet-service";
import { MastercardWalletService } from './mastercard.wallet-service';
import { EventEmitter } from "../helper/event-emitter";
import { AccessToken } from "../helper/access-token";
import { ApiInternal, API_AUTH_TYPE } from "../api/api-internal";
import { WALLET_EVENT } from "./wallet-service";
/**
 * List of available event's name in the wallet button lifecycle
 * @const EVENT
 *
 * @type {object}
 * @param {string} UNAVAILABLE=unavailable
 * @param {string} UPDATE=update
 * @param {string} PAYMENT_SUCCESSFUL=paymentSuccessful
 * @param {string} PAYMENT_ERROR=paymentError
 */
export const EVENT = {
    UNAVAILABLE: "unavailable",
    UPDATE: "update",
    PAYMENT_SUCCESSFUL: "paymentSuccessful",
    PAYMENT_ERROR: "paymentError",
    PAYMENT_IN_REVIEW: "paymentInReview",
};
/**
 * Interface of data used by the wallet checkout and payment proccess.
 * @interface IWalletMeta
 *
 * @type {object}
 * @param {string} [amount_label] Label shown next to the total amount to be paid. Required for [Stripe, ApplePay, GooglePay]. N/A for [FlyPay, PayPal].
 * @param {string} [country] Country of the user. 2 letter ISO code format. Required for [Stripe, ApplePay, GooglePay]. N/A for [FlyPay, PayPal].
 * @param {string} [pay_later] Used to enable Pay Later feature in PayPal Smart Checkout WalletButton integration when available. Optional for [PayPal]. N/A for other wallets.
 * @param {boolean} [show_billing_address] Used to hide/show the billing address on ApplePay and GooglePay popups. Default value is false. Optional for [ApplePay, GooglePay]. N/A for other wallets.
 * @param {boolean} [request_payer_name] Used mainly for fraud purposes - recommended set to true. Optional for [Stripe]. N/A for other wallets.
 * @param {boolean} [request_payer_email] Used mainly for fraud purposes - recommended set to true. Optional for [Stripe]. N/A for other wallets.
 * @param {boolean} [request_payer_phone] Used mainly for fraud purposes - recommended set to true. Optional for [Stripe]. N/A for other wallets.
 * @param {boolean} [request_shipping] Used to request or not shipping address in the Wallet checkout, being able to handle amount changes via the `update` event. Optional for [FlyPay, PayPal, ApplePay, GooglePay]. N/A for [Stripe].
 * @param {IApplePayShippingOption[] | IPayPalShippingOption[]} [shipping_options] Used to provide available shipping options.(To use shipping_options the request_shipping flag should be true). Optional for [ApplePay]. N/A for the other wallets.
 * @param {string} [merchant_name] Merchant Name used for GooglePay integration via MPGS. Required for [GooglePay]. N/A for other wallets.
 * @param {object} [raw_data_initialization] Used to provide values to initialize wallet with raw data. Optional for [ApplePay]. N/A for the other wallets.
 * @param {object} [style] Used to style PayPal buttons, check possible values at https://developer.paypal.com/docs/business/checkout/reference/style-guide. Also used at ApplePay to select button type. Optional for [PayPal, ApplePay]. N/A for [Stripe, FlyPay].
 * @param {object} [style.button_type] Used to select ApplePay button type (e.g: 'buy','donate', etc), check possible values at https://developer.apple.com/documentation/apple_pay_on_the_web/displaying_apple_pay_buttons_using_css. Optional for [ApplePay]. N/A for other wallets.
 * @param {array} [wallets] By default if this is not sent or empty, we will try to show either Apple Pay or Google Pay buttons. This can be limited sending the following array in this field: ['apple','google]. Optional for [Stripe, ApplePay, GooglePay]. N/A for other wallets.
 */
/**
 * Interface of Shipping Options for ApplePay
 * @interface IApplePayShippingOption
 *
 * @type {object}
 * @param {string} [id] Identifier of the Shipping Option. Required.
 * @param {string} [label] Identifier of the Shipping Option. Required.
 * @param {string} [amount] Amount of the Shipping Option. Required.
 * @param {string} [detail] Details of the Shipping Option. Required.
 * @param {string} [type] Type of the Shipping Option. Values can be 'ELECTRONIC', 'GROUND', 'NOT_SHIPPED', 'OVERNIGHT', 'PICKUP', 'PRIORITY', 'SAME_DAY'. Optional.
 */
/**
 * Interface of Shipping Options for GooglePay
 * @interface IGooglePayShippingOption
 *
 * @type {object}
 * @param {string} [id] Identifier of the Shipping Option. Required.
 * @param {string} [label] Identifier of the Shipping Option. Required.
 * @param {string} [detail] Details of the Shipping Option. Optional.
 * @param {string} [type] Type of the Shipping Option. Values can be 'ELECTRONIC', 'GROUND', 'NOT_SHIPPED', 'OVERNIGHT', 'PICKUP', 'PRIORITY', 'SAME_DAY'. Optional.
 */
/**
 * Interface of Shipping Options for PayPal
 * @interface IPayPalShippingOption
 *
 * @type {object}
 * @param {string} [id] Identifier of the Shipping Option. Required.
 * @param {string} [label] Identifier of the Shipping Option. Required.
 * @param {string} [amount] Amount of the Shipping Option. Required.
 * @param {string} [currency] Currency of the Shipping Option. Required.
 * @param {string} [type] Type of the Shipping Option. Values can be 'SHIPPING' or 'PICKUP'. Required.
 */
/**
 * Class WalletButtons to work with different E-Wallets within html (currently supports Apple Pay, Google Payâ„¢ and Apple Pay via Stripe, Flypay, Paypal)
 * @constructor
 *
 * @example
 * var button = new WalletButtons('#wallet-buttons', 'charge-token', { amount_label: 'Total', country: 'us' });
 *
 * @param {string} selector - Selector of html element. Container for the WalletButtons.
 * @param {string} chargeToken - token for the wallet transaction, created with a secure call to `POST charges/wallet`.
 * @param {IWalletMeta} object - data that configures the E-Wallet, which can be shown on checkout page and configures required customer information.
 **/
export class WalletButtons {
    constructor(selector, chargeToken, meta) {
        this.hasUpdateHandler = false;
        const parsedToken = AccessToken.validateJWT(chargeToken);
        if (!parsedToken)
            throw new Error(("Invalid charge token"));
        this.eventEmitter = new EventEmitter();
        this.container = new Container(selector);
        const tokenMeta = AccessToken.extractMeta(parsedToken.body);
        this.api = new ApiInternal(chargeToken, API_AUTH_TYPE.TOKEN);
        switch (tokenMeta.gateway.type) {
            case WALLET_GATEWAY.STRIPE:
                this.service = new StripeWalletService(tokenMeta.credentials.client_auth, Object.assign(Object.assign({}, meta), { amount: tokenMeta.charge.amount, currency: tokenMeta.charge.currency }));
                break;
            case WALLET_GATEWAY.FLYPAY:
                this.service = new FlypayWalletService(chargeToken, Object.assign(Object.assign({}, meta), { id: tokenMeta.charge.id, gateway_mode: tokenMeta.gateway.mode, amount: tokenMeta.charge.amount, currency: tokenMeta.charge.currency }));
                break;
            case WALLET_GATEWAY.PAYPAL:
                this.service = new PaypalWalletService(tokenMeta.credentials.client_auth, Object.assign(Object.assign({}, meta), { id: tokenMeta.charge.id, gateway_mode: tokenMeta.gateway.mode, amount: tokenMeta.charge.amount, currency: tokenMeta.charge.currency, capture: tokenMeta.charge.capture }));
                break;
            case WALLET_GATEWAY.MASTERCARD:
                this.service = new MastercardWalletService('', Object.assign(Object.assign({}, meta), { credentials: tokenMeta.gateway.credentials, amount: tokenMeta.charge.amount, currency: tokenMeta.charge.currency }));
                break;
        }
    }
    /**
     * Initializes the availability checks and inserts the button if possible.
     * Otherwise function onUnavailable(handler: VoidFunction) will be called.
     *
     * @example
     * var button = new WalletButtons(
     *      '#buttons',
     *      token,
     *      {
     *          amount_label: 'Total',
     *          country: 'DE',
     *      }
     *  );
     *  button.load();
     */
    load() {
        try {
            this.setupServiceCallbacks();
            this.service.load(this.container);
        }
        catch (err) {
            this.eventEmitter.emit(EVENT.UNAVAILABLE, null);
            throw err;
        }
    }
    /**
     * Triggers the update process of the wallet, if available.
     * Currently supported by Flypay, Paypal and ApplePay/GooglePay via MPGS Wallets.
     *
     * @example
     * var button = new WalletButtons(
     *      '#buttons',
     *      token,
     *      {
     *          amount_label: 'Total',
     *          country: 'DE',
     *      }
     *  );
     *  button.on('update', (data) => {
     *      updateChargeAmountInBackend(data);
     *      button.update({ success: true });
     *  });
     *
     * @example
     * // ApplePay via MPGS example:
     * var button = new WalletButtons(
     *      '#buttons',
     *      token,
     *      {
     *          amount_label: 'Total',
     *          country: 'AU',
     *          ...
     *      }
     *  );
     *  button.on('update', (data) => {
     *      updateChargeAmountInBackend(data);
     *      button.update({
     *         success: true,
     *         body: {
     *              amount: 15,
     *              shipping_options: [
     *                   {
     *                      id: "NEW-FreeShip",
     *                       label: "NEW - Free Shipping",
     *                       detail: "Arrives in 3 to 5 days",
     *                       amount: "0.00"
     *                   },
     *                   {
     *                       id: "NEW - FastShip",
     *                       label: "NEW - Fast Shipping",
     *                       detail: "Arrives in less than 1 day",
     *                       amount: "10.00"
     *                   }
     *               ]
     *          }
     *       });
     *  });
     */
    update(data) {
        this.service.update(data);
    }
    /**
     * Current method can change environment. By default environment = sandbox.
     * Also we can change domain alias for this environment. By default domain_alias = paydock.com
     * Bear in mind that you must set an environment before calling `button.load()`.
     *
     * @example
     * button.setEnv('production', 'paydock.com');
     * @param {string} env - sandbox, production
     * @param {string} [alias] - Own domain alias
     */
    setEnv(env, alias) {
        this.api.setEnv(env, alias);
        this.service.setEnv(env);
    }
    /**
     * Closes the checkout forcibly. Currently supported in Flypay wallet.
     *
     * @example
     * button.close();
     */
    close() {
        if (typeof this.service.close === 'function') {
            this.service.close();
        }
    }
    /**
     * Listen to events of button. `unavailable` returns no data, `paymentSuccessful` returns IWalletPaymentSuccessful
     * for Stripe or full response for Flypay, and `paymentError` an error.
     *
     * NOTE: when listening for the 'update' event, make sure to call the `button.update(result)` method on completion.
     *
     * @example
     *
     * button.on('paymentSuccessful', function (data) {
     *      console.log(data);
     * });
     * // or
     * button.on('unavailable').then(function () {
     *      console.log('No button is available);
     * });
     *
     * @param {string} eventName - Available event names [EVENT]{@link EVENT}
     * @param {listener} [cb]
     * @return {Promise<IEventData> | void}
     */
    on(eventName, cb) {
        if (eventName === EVENT.UPDATE)
            this.hasUpdateHandler = true;
        if (typeof cb === 'function')
            return this.eventEmitter.subscribe(eventName, cb);
        return new Promise((resolve) => this.eventEmitter.subscribe(eventName, (res) => resolve(res)));
    }
    /**
     * User to subscribe to the no button available event. This method is used after loading when the button is not available.
     * For MPGS, since can have more than one wallet button configured (ApplePay/GooglePay) you will receive a body (({ wallet: WALLET_TYPE.GOOGLE }) or ({ wallet: WALLET_TYPE.APPLE })) indicating which button is unavailable
     * Important: Do not perform thread blocking operations in callback such as window.alert() calls.
     *
     * @example
     * button.onUnavailable(() => {
     *      console.log('No wallet buttons available');
     * });
     *
     * @example
     * button.onUnavailable().then(() => console.log('No wallet buttons available'));
     *
     * @example
     * button.onUnavailable(function (data) {console.log('data.wallet :: ', data.wallet)});
     *
     * @param {listener} [handler] - Function to be called when no button is available.
     */
    onUnavailable(handler) {
        if (typeof handler === 'function')
            return this.eventEmitter.subscribe(EVENT.UNAVAILABLE, handler);
        return new Promise((resolve) => this.eventEmitter.subscribe(EVENT.UNAVAILABLE, () => resolve()));
    }
    /**
     * If the wallet performs some update in the checkout process, the function passed as parameter will be called.
     *
     * NOTE: make sure to call the `button.update(result)` method on handler completion.
     *
     * @example
     * button.onUpdate((data) => {
     *      button.update({ success: true });
     * });
     *
     * @example
     * button.onUpdate().then((data) => throw new Error());
     *
     * @param {listener} [handler] - Function to be called when the payment was successful.
     */
    onUpdate(handler) {
        this.hasUpdateHandler = true;
        if (typeof handler === 'function')
            return this.eventEmitter.subscribe(EVENT.UPDATE, handler);
        return new Promise((resolve) => this.eventEmitter.subscribe(EVENT.UPDATE, (data) => resolve(data)));
    }
    /**
     * If the payment was successful, the function passed as parameter will be called.
     * Important: Do not perform thread blocking operations in callback such as window.alert() calls.
     *
     * @example
     * button.onPaymentSuccessful((data) => {
     *      console.log('Payment successful!');
     * });
     *
     * @example
     * button.onPaymentSuccessful().then((data) => console.log('Payment successful!'));
     *
     * @param {listener} [handler] - Function to be called when the payment was successful.
     */
    onPaymentSuccessful(handler) {
        if (typeof handler === 'function')
            return this.eventEmitter.subscribe(EVENT.PAYMENT_SUCCESSFUL, handler);
        return new Promise((resolve) => this.eventEmitter.subscribe(EVENT.PAYMENT_SUCCESSFUL, (data) => resolve(data)));
    }
    /**
     * If the payment was left in fraud review, the function passed as parameter will be called.
     * Important: Do not perform thread blocking operations in callback such as window.alert() calls.
     *
     * @example
     * button.onPaymentInReview((data) => {
     *      console.log('Payment in fraud review');
     * });
     *
     * @example
     * button.onPaymentInReview().then((data) => console.log('Payment in fraud review'));
     *
     * @param {listener} [handler] - Function to be called when the payment was left in fraud review status.
     */
    onPaymentInReview(handler) {
        if (typeof handler === 'function')
            return this.eventEmitter.subscribe(EVENT.PAYMENT_IN_REVIEW, handler);
        return new Promise((resolve) => this.eventEmitter.subscribe(EVENT.PAYMENT_IN_REVIEW, (data) => resolve(data)));
    }
    /**
     * If the payment was not successful, the function passed as parameter will be called.
     * Important: Do not perform thread blocking operations in callback such as window.alert() calls.
     *
     * @example
     * button.onPaymentError((err) => {
     *      console.log('Payment not successful');
     * });
     *
     * @example
     * button.onPaymentError().then((err) => console.log('Payment not successful'));
     *
     * @param {listener} [handler] - Function to be called when the payment was not successful.
     */
    onPaymentError(handler) {
        if (typeof handler === 'function')
            return this.eventEmitter.subscribe(EVENT.PAYMENT_ERROR, handler);
        return new Promise((resolve) => this.eventEmitter.subscribe(EVENT.PAYMENT_ERROR, (err) => resolve(err)));
    }
    setupServiceCallbacks() {
        this.setupUnavailableCallback();
        this.setupUpdateCallback();
        this.setupWalletCallback();
        this.setupPaymentCallback();
        this.setupPaymentSuccessCallback();
        this.setupPaymentInReviewCallback();
        this.setupPaymentErrorCallback();
    }
    setupUnavailableCallback() {
        this.service.on(WALLET_EVENT.UNAVAILABLE, (eventData) => this.eventEmitter.emit(EVENT.UNAVAILABLE, { event: EVENT.UNAVAILABLE, data: eventData }));
    }
    setupUpdateCallback() {
        this.service.on(WALLET_EVENT.UPDATE, (eventData) => this.hasUpdateHandler
            ? this.eventEmitter.emit(EVENT.UPDATE, { event: EVENT.UPDATE, data: eventData })
            : this.update({ success: true }));
    }
    setupWalletCallback() {
        this.service.on(WALLET_EVENT.CALLBACK, (eventData) => {
            const { data, onSuccess, onError } = eventData;
            this.api
                .charge()
                .walletCallback(data)
                .then((res) => onSuccess(res), (err) => onError(err.message));
        });
    }
    setupPaymentCallback() {
        this.service.on(WALLET_EVENT.PAYMENT_METHOD_SELECTED, (eventData) => {
            const { data, onSuccess, onError } = eventData;
            this.api
                .charge()
                .walletCapture(data)
                .then((captureResult) => {
                if (typeof onSuccess === 'function')
                    onSuccess();
                const event = captureResult.status === 'inreview' ? EVENT.PAYMENT_IN_REVIEW : EVENT.PAYMENT_SUCCESSFUL;
                this.eventEmitter.emit(event, {
                    event: event,
                    data: Object.assign(Object.assign({}, captureResult), data.customer && {
                        payer_name: data.customer.payer_name,
                        payer_email: data.customer.payer_email,
                        payer_phone: data.customer.payer_phone,
                    }),
                });
            }, (err) => {
                if (typeof onError === 'function')
                    onError(err);
                this.eventEmitter.emit(EVENT.PAYMENT_ERROR, { event: EVENT.PAYMENT_ERROR, data: err });
            });
        });
    }
    setupPaymentSuccessCallback() {
        this.service.on(WALLET_EVENT.PAYMENT_SUCCESS, (eventData) => this.eventEmitter.emit(EVENT.PAYMENT_SUCCESSFUL, { event: EVENT.PAYMENT_SUCCESSFUL, data: eventData }));
    }
    setupPaymentInReviewCallback() {
        this.service.on(WALLET_EVENT.PAYMENT_IN_REVIEW, (eventData) => this.eventEmitter.emit(EVENT.PAYMENT_IN_REVIEW, { event: EVENT.PAYMENT_IN_REVIEW, data: eventData }));
    }
    setupPaymentErrorCallback() {
        this.service.on(WALLET_EVENT.PAYMENT_ERROR, (eventData) => this.eventEmitter.emit(EVENT.PAYMENT_ERROR, { event: EVENT.PAYMENT_ERROR, data: eventData }));
    }
}
//# sourceMappingURL=../../src/lib/wallet-buttons/wallet-buttons.js.map