import { Env, ENV } from '../components/env';
import { ObjectHelper } from '../helper/object';
import { FORM_FIELD, SUPPORTED_CHECKOUT_META_COLLECTION, } from "../components/param";
/**
 * List of available payment source types
 *
 * @type {object}
 * @param {string} CARD=card
 * @param {string} BANK_ACCOUNT=bank_account
 * @param {string} CHECKOUT=checkout
 */
export const PAYMENT_TYPE = {
    CARD: 'card',
    BANK_ACCOUNT: 'bank_account',
    CHECKOUT: 'checkout',
};
/**
 * Purposes
 * @type {object}
 * @param {string} PAYMENT_SOURCE=payment_source
 * @param {string} CARD_PAYMENT_SOURCE_WITH_CVV=card_payment_source_with_cvv
 * @param {string} CARD_PAYMENT_SOURCE_WITHOUT_CVV=card_payment_source_without_cvv
 * */
export const PURPOSE = {
    PAYMENT_SOURCE: 'payment_source',
    CARD_PAYMENT_SOURCE_WITH_CVV: 'card_payment_source_with_cvv',
    CARD_PAYMENT_SOURCE_WITHOUT_CVV: 'card_payment_source_without_cvv',
};
const CONFIGURATION_LINK = '/v1/remote-action/configs';
/**
 * Class Configuration include methods for creating configuration token
 * @constructor
 *
 * @example
 * var config = new Configuration('gatewayId'); // short
 *
 * var config = new Configuration('gatewayId', 'bank_account', 'paymentSource'); // extend
 *
 * @param {string} [gatewayID=default] - gateway ID. By default or if put 'default', it will use the selected default gateway
 * @param {string} paymentType - Type of payment source which shows in widget form. Available parameters [PAYMENT_TYPE]{@link PAYMENT_TYPE}
 * @param {string} purpose - Param which describes payment purpose. By default uses Available parameters [PURPOSE]{@link PURPOSE}
 **/
export class Configuration {
    constructor(gatewayID = 'default', paymentType = PAYMENT_TYPE.CARD, purpose = PURPOSE.PAYMENT_SOURCE) {
        if (ObjectHelper.values(PAYMENT_TYPE).indexOf(paymentType) === -1)
            throw new Error('unsupported payment type');
        else if (paymentType === PAYMENT_TYPE.CHECKOUT)
            throw new Error('Payment type "checkout" is deprecated. Use CheckoutButton for this type of payments https://www.npmjs.com/package/@paydock/client-sdk#checkout-button');
        if (ObjectHelper.values(PURPOSE).indexOf(purpose) === -1)
            throw new Error('unsupported purpose');
        this.env = new Env([
            { env: ENV.SANDBOX_KOVENA, url: 'https://api-sandbox.' },
            { env: ENV.SANDBOX_DEMO, url: 'https://api-sandbox-demo.' },
            { env: ENV.SANDBOX_DEMO_KOVENA, url: 'https://api-sandbox-demo.' },
            { env: ENV.SANDBOX, url: 'https://api-sandbox.' },
            { env: ENV.PROD, url: 'https://api.' },
            { env: ENV.STAGING, url: 'https://apista.' },
            { env: ENV.STAGING_2, url: 'https://apista-2.' },
            { env: ENV.STAGING_3, url: 'https://apista-3.' },
            { env: ENV.STAGING_4, url: 'https://apista-4.' },
            { env: ENV.STAGING_5, url: 'https://apista-5.' },
        ]);
        this.configs = {
            purpose: purpose,
            meta: {},
            dynamic_fields_position: true,
            predefined_fields: {
                gateway_id: gatewayID,
                type: paymentType,
            },
        };
    }
    static createEachToken(publicKey, configs, cb, errorCb = (errors) => { }) {
        let tokens = new Array(configs.length);
        let errors = [];
        let counter = 0;
        for (let index in configs) {
            if (configs.hasOwnProperty(index))
                configs[index].createToken(publicKey, (token) => {
                    tokens[index] = token;
                    counter++;
                    if (configs.length === counter)
                        Configuration.finishCreatingEachToken(tokens, errors, cb, errorCb);
                }, (err) => {
                    errors.push(`gateway: ${configs[index].getConfigs().predefined_fields.gateway_id} | ${err}`);
                    counter++;
                    if (configs.length === counter)
                        Configuration.finishCreatingEachToken(tokens, errors, cb, errorCb);
                });
        }
    }
    static finishCreatingEachToken(tokens, errors, cb, errorCb) {
        if (errors.length >= 1)
            errorCb(errors);
        else
            cb(tokens);
    }
    /**
     * Destination, where customer will receive all successful responses.
     * Response will contain “data” object with “payment_source” or other parameters, in depending on 'purpose'
     *
     * @example
     * config.setWebHookDestination('http://google.com');
     *
     * @param {string} url - Your endpoint for post request.
     */
    setWebHookDestination(url) {
        this.configs.webhook_destination = url;
    }
    /**
     * URL to which the Customer will be redirected to after the success finish
     *
     * @example
     * config.setSuccessRedirectUrl('google.com/search?q=success');
     *
     * @param {string}  url
     */
    setSuccessRedirectUrl(url) {
        this.configs.success_redirect_url = url;
    }
    /**
     * URL to which the Customer will be redirected to if an error is triggered in the process of operation
     *
     * @example
     * config.setErrorRedirectUrl('google.com/search?q=error');
     *
     * @param {string} url
     */
    setErrorRedirectUrl(url) {
        this.configs.error_redirect_url = url;
    }
    /**
     *  Set list with widget form field, which will be shown in form. Also you can set the required validation for these fields
     *
     * @example
     * config.setFormFields(['phone', 'email', 'first_name*']);
     *
     * @param {string[]} fields - name of fields which can be shown in a widget.
     *   If after a name of a field, you put “*”, this field will be required on client-side.
     *   (For validation, you can specify any fields, even those that are shown by default: card_number, expiration, etc... ) [FORM_FIELD]{@link FORM_FIELD}
     */
    setFormFields(fields) {
        if (!Array.isArray(this.configs.defined_form_fields))
            this.configs.defined_form_fields = [];
        for (let index in fields) {
            if (!fields.hasOwnProperty(index))
                continue;
            if (ObjectHelper.values(FORM_FIELD).indexOf(fields[index].replace('*', '')) !== -1)
                this.configs.defined_form_fields.push(fields[index]);
            else
                console.warn(`Configuration::setFormFields: unsupported form field ${fields[index]}`);
        }
    }
    /**
     * Method for setting meta information for checkout page
     *
     * @example
     * config.setMeta({
            brand_name: 'paydock',
            reference: '15',
            email: 'wault@paydock.com'
        });
     *
     * @param {IPayPalMeta | IZipmoneyMeta | IAfterpayMeta | IBamboraMeta} object -
     *    data which can be shown on checkout page [IPayPalMeta]{@link IPayPalMeta} [IZipmoneyMeta]{@link IZipmoneyMeta} [IAfterpayMeta]{@link IAfterpayMeta} [IBamboraMeta]{@link IBamboraMeta}
     */
    setMeta(meta) {
        for (let key in meta) {
            if (!meta.hasOwnProperty(key))
                continue;
            if (SUPPORTED_CHECKOUT_META_COLLECTION.indexOf(key) !== -1)
                this.configs.meta[key] = meta[key];
            else
                console.warn(`Configuration::setMeta: unsupported meta key ${key}`);
        }
    }
    /**
     * Current method can change environment. By default environment = sandbox.
     * Also we can change domain alias for this environment. By default domain_alias = paydock.com
     *
     * @example
     * config.setEnv('production');
     * @param {string} env - sandbox, production
     * @param {string} [alias] - Own domain alias
     */
    setEnv(env, alias) {
        this.env.setEnv(env, alias);
    }
    /**
     * Title for tab which can be set instead of default
     *
     * @example
     * config.setLabel('custom label');
     *
     * @param {string} label - Text label for tab
     */
    setLabel(label) {
        this.configs.label = label;
    }
    getEnv() {
        return this.env.getEnv();
    }
    /**
     * createToken - method which exactly create payment one time token
     *
     * @example
     * config.createToken('582035346f65cdd57ee81192d6e5w65w4e5',
     *  function (data) {
     *      console.log(data);
     *  }, function (error) {
     *      console.log(error);
     * });
     *
     * @param {string} publicKey - Customer public key which provided for each client
     * @param {createToken~requestCallback} cb - The callback that handles the success response.
     * @param {createToken~requestCallback} errorCb - The callback that handles the failed response.
     */
    createToken(publicKey, cb, errorCb = (err) => { }) {
        this.send(publicKey, (data, status) => {
            if (status >= 200 && status < 300)
                return cb(data.resource.data.configuration_token);
            if (typeof data.error === "undefined" || typeof data.error.message === "undefined")
                errorCb('unknown error');
            else
                errorCb(data.error.message);
        });
    }
    send(publicKey, cb) {
        let request = new XMLHttpRequest();
        request.open('POST', this.getUrl(), true);
        request.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
        request.setRequestHeader('x-user-public-key', publicKey);
        request.send(JSON.stringify(this.getConfigs()));
        request.onload = () => {
            let res = {};
            try {
                res = JSON.parse(request.responseText);
            }
            catch (e) { }
            cb(res, request.status);
        };
    }
    getConfigs() {
        return this.configs;
    }
    getUrl() {
        return this.env.getConf().url + CONFIGURATION_LINK;
    }
}
//# sourceMappingURL=../../src/lib/widget/configuration.js.map