import { Link, WIDGET_LINK } from '../components/link';
import { Configuration } from './configuration';
import { STYLE, TEXT, ELEMENT, SUPPORTED_CARD_TYPES, FORM_FIELD, } from '../components/param';
import { ObjectHelper } from '../helper/object';
import { stylableElements, } from "./style";
import { ElementStyle } from "../components/element-style";
/**
 *
 * Class MultiWidget include method for for creating iframe url
 * @constructor
 *
 * @param {string} publicKey - PayDock users public key
 * @param {(Configuration | string | Configuration[] | string[])} conf - exemplar[s] Configuration class OR configuration token
 *
 * @example
 * var widget = new MultiWidget('publicKey','configurationToken'); // With a pre-created configuration token
 *
 * var widget = new MultiWidget('publicKey',['configurationToken', 'configurationToken2']); // With pre-created configuration tokens
 *
 * var widget = new MultiWidget('publicKey', new Configuration('gatewayId')); With Configuration
 *
 * var widget = new MultiWidget('publicKey',[ With Configurations
 *      Configuration('gatewayId'),
 *      Configuration('gatewayId', 'bank_account')
 * ]);
 **/
export class MultiWidget {
    constructor(publicKey, conf) {
        this.configs = [];
        this.configTokens = [];
        this.link = new Link(WIDGET_LINK);
        this.link.setParams({ public_key: publicKey });
        this.publicKey = publicKey;
        if (!conf || (Array.isArray(conf) && !conf.length))
            throw Error('configuration token is required');
        if (typeof conf === 'string')
            this.configTokens.push(conf);
        else if (conf instanceof Configuration)
            this.configs.push(conf);
        else if (Array.isArray(conf) && typeof conf[0] === 'string')
            this.configTokens = conf;
        else if (Array.isArray(conf) && conf[0] instanceof Configuration)
            this.configs = conf;
        else
            throw Error('Unsupported type of configuration token');
    }
    /**
     * Object contain styles for widget
     *
     * @example
     * widget.setStyles({
     *       background_color: 'rgb(0, 0, 0)',
     *       border_color: 'yellow',
     *       text_color: '#FFFFAA',
     *       button_color: 'rgba(255, 255, 255, 0.9)',
     *       font_size: '20px'
     *       fort_family: 'fantasy'
     *   });
     * @param {IStyles} fields - name of styles which can be shown in widget [STYLE]{@link STYLE}
     */
    setStyles(styles) {
        for (let index in styles) {
            if (styles.hasOwnProperty(index))
                this.setStyle(index, styles[index]);
        }
    }
    /**
     * Method to set a country code mask for the phone input.
     *
     * @example
     * widget.usePhoneCountryMask();
     *
     * @example
     * widget.usePhoneCountryMask({
     *       default_country: 'au',
     *       preferred_countries: ['au', 'gb'],
     *       only_countries: ['au', 'gb', 'us', 'ua']
     *   });
     *
     * @param {object} [options] - Options for configure the phone mask.
     * @param {string} [options.default_country] - Set a default country for the mask.
     * @param {Array.<string>} [options.preferred_countries] - Set list of preferred countries for the top of the select box .
     * @param {Array.<string>} [options.only_countries] - Set list of countries to show in the select box.
     */
    usePhoneCountryMask(options) {
        if (!options)
            return this.link.setParams({ use_country_phone_mask: true });
        if (options.only_countries && (!/^[a-z]+$/.test(options.only_countries.join('')) || options.only_countries.length * 2 !== options.only_countries.join('').length))
            return console.warn(`Widget::usePhoneCountryMask[s: only_countries - unsupported symbols or incorrect length of value`);
        if (options.preferred_countries && (!/^[a-z]+$/.test(options.preferred_countries.join('')) || options.preferred_countries.length * 2 !== options.preferred_countries.join('').length))
            return console.warn(`Widget::usePhoneCountryMask[s: preferred_countries - unsupported symbols or incorrect length of value`);
        if (options.default_country && options.default_country.length !== 2)
            return console.warn(`Widget::usePhoneCountryMask[s: default_country - incorrect value length`);
        this.link.setParams({ use_country_phone_mask: true });
        if (options.only_countries)
            this.link.setParams({ phone_mask_only_countries: options.only_countries.join(',') });
        if (options.preferred_countries)
            this.link.setParams({ phone_mask_preferred_countries: options.preferred_countries.join(',') });
        if (options.default_country)
            this.link.setParams({ phone_mask_default_country: options.default_country });
    }
    setStyle(param, value) {
        if (ObjectHelper.values(STYLE).indexOf(param) !== -1)
            this.link.setParams({ [param]: value });
        else
            console.warn(`Widget::setStyle[s: unsupported style param ${param}`);
    }
    /**
     * Method for set different texts inside the widget
     *
     * @example
     * widget.setTexts({
     *       title: 'Your card',
     *       finish_text: 'Payment resource was successfully accepted',
     *       title_description: '* indicates required field',
     *       submit_button: 'Save',
     *       submit_button_processing: 'Load...',
     *   });
     *
     * @param {ITexts} fields - name of text items which can be shown in widget [TEXT]{@link TEXT}
     */
    setTexts(texts) {
        for (let index in texts) {
            if (texts.hasOwnProperty(index))
                this.setText(index, texts[index]);
        }
    }
    setText(param, value) {
        if (ObjectHelper.values(TEXT).indexOf(param) !== -1)
            this.link.setParams({ [param]: value });
        else
            console.warn(`Widget::setText[s: unsupported text param ${param}`);
    }
    /**
     * Method for set styles for different elements and states
     *
     * @example
     * widget.setElementStyle('input', {
     *   border: 'green solid 1px'
     * });
     *
     * widget.setElementStyle('input', 'focus', {
     *   border: 'blue solid 1px'
     * });
     *
     * widget.setElementStyle('input', 'error', {
     *  border: 'red solid 1px'
     * });
     *
     * @param {string} element - type of element for styling. These elements are available [STYLABLE_ELEMENT]{@link STYLABLE_ELEMENT}
     * @param {string} [state] - state of element for styling. These states are available [STYLABLE_ELEMENT_STATE]{@link STYLABLE_ELEMENT_STATE}
     * @param {IElementStyleInput | IElementStyleSubmitButton | IElementStyleLabel | IElementStyleTitle | IElementStyleTitleDescription} styles - styles list
     */
    setElementStyle(element, a2, a3) {
        let state = (arguments.length === 3)
            ? a2
            : null;
        let styles = (arguments.length === 3)
            ? a3
            : a2;
        if (!ElementStyle.check(stylableElements, element, state, styles))
            return console.warn(`Styles for "${element}" element with "${state || 'default'}" state was ignored because some of the arguments are unacceptable`);
        this.link.concatParams({ element_styles: ElementStyle.encode(element, state, styles) });
    }
    /**
   * The method to set the predefined values for the form fields inside the widget
   *
   * @example
   *   widget.setFormValues({
   *       email: 'predefined@email.com',
   *       card_name: 'Houston'
   *   });
   *
   * @param { Object } fieldValues - Key of object is one of [FORM_FIELD]{@link FORM_FIELD}, The object value is what we are expecting
   */
    setFormValues(fieldValues) {
        for (let key in fieldValues) {
            if (fieldValues.hasOwnProperty(key))
                this.setFormValue(key, fieldValues[key]);
        }
    }
    setFormValue(key, value) {
        if (ObjectHelper.values(FORM_FIELD).indexOf(key) === -1)
            return console.warn(`Widget::setFormValues[s: unsupported field ${key}`);
        if (/\,/.test(value) || /\:/.test(value))
            return console.warn(`Widget::setFormValues[s: ${key} - unsupported symbols (: or ,) in value`);
        if (typeof this.link.getParams().form_values === 'string' && this.link.getParams().form_values.length)
            this.link.setParams({ form_values: `${this.link.getParams().form_values},${key}:${value}` });
        else
            this.link.setParams({ form_values: `${key}:${value}` });
    }
    /**
     * The method to set custom form field labels
     *
     * @example
     *   widget.setFormPlaceholders({
     *       card_name: 'Card Holder Name',
     *       email: 'Email For Receipt'
     *   })
     *
     * @param { Object } fieldLabels - Key of object is one of [FORM_FIELD]{@link FORM_FIELD}, The object value is what we are expecting
     */
    setFormLabels(fieldLabels) {
        for (let key in fieldLabels) {
            if (fieldLabels.hasOwnProperty(key))
                this.setFormLabel(key, fieldLabels[key]);
        }
    }
    setFormLabel(key, label) {
        if (ObjectHelper.values(FORM_FIELD).indexOf(key) === -1)
            return console.warn(`Widget::setFormLabel[s: unsupported field ${key}`);
        const modifiedLabel = (label === null || label === '')
            ? ' '
            : label;
        if (/\,/.test(modifiedLabel) || /\:/.test(modifiedLabel))
            return console.warn(`Widget::setFormLabel[s: ${key} - unsupported symbols (: or ,) in value`);
        this.link.concatParams({ form_labels: `${key}:${modifiedLabel}` });
    }
    /**
     * The method to set custom form fields placeholders
     *
     * @example
     *   widget.setFormPlaceholders({
     *       card_name: 'Input your card holder name...',
     *       email: 'Input your email, like test@example.com'
     *   })
     *
     * @param { Object } fieldPlaceholders - Key of object is one of [FORM_FIELD]{@link FORM_FIELD}, Value of object is expected placeholder
     */
    setFormPlaceholders(fieldPlaceholders) {
        for (let key in fieldPlaceholders) {
            if (fieldPlaceholders.hasOwnProperty(key))
                this.setFormPlaceholder(key, fieldPlaceholders[key]);
        }
    }
    setFormPlaceholder(key, placeholder) {
        if (ObjectHelper.values(FORM_FIELD).indexOf(key) === -1)
            return console.warn(`Widget::setFormPlaceholder[s: unsupported field ${key}`);
        const modifiedPlaceholder = (placeholder === null || placeholder === '')
            ? ' '
            : placeholder;
        if (/\,/.test(modifiedPlaceholder) || /\:/.test(modifiedPlaceholder))
            return console.warn(`Widget::setFormPlaceholder[s: ${key} - unsupported symbols (: or ,) in value`);
        this.link.concatParams({ form_placeholders: `${key}:${modifiedPlaceholder}` });
    }
    /**
     * The method to set the full configuration for the all specific form elements (label, placeholder, value)
     * You can also use the other method for the partial configuration like: setFormValues, setFormPlaceholder, setFormLabel
     *
     * @example
     *   widget.setFormElements([
     *       {
     *           field:  'card_name',
     *           placeholder: 'Input your card holder name...',
     *           label: 'Card Holder Name',
     *           value: 'Houston',
     *       },
     *       {
     *           field:  'email',
     *           placeholder: 'Input your email, like test@example.com',
     *           label: 'Email For Receipt',
     *           value: 'predefined@email.com',
     *       },
     *   ])
     *
     * @param { string } elements - The list of elements
     * @param { string } elements[].field - Field name of the element [FORM_FIELD]{@link FORM_FIELD}
     * @param { string } elements[].placeholder - Set custom form field placeholder
     * @param { string } elements[].label - Set custom labels near form field
     * @param { string } elements[].value - Set predefined values for the form field
     */
    setFormElements(elements) {
        elements.forEach((element) => this.setFormElement(element));
    }
    setFormElement(element) {
        if (element.value)
            this.setFormValue(element.field, element.value);
        if (element.label)
            this.setFormLabel(element.field, element.label);
        if (element.placeholder)
            this.setFormPlaceholder(element.field, element.placeholder);
    }
    /**
     * The method to change the widget icons
     *
     * @TODO DEPRECATED
     */
    setIcons(icons) {
        for (let key in icons) {
            if (icons.hasOwnProperty(key))
                this.setIcon(key, icons[key]);
        }
    }
    setIcon(key, value) {
        if (/\,/.test(value) || /\:/.test(value))
            return console.warn(`Widget::setIcon[s: ${key} - unsupported symbols (: or ,) in value`);
        if (typeof this.link.getParams().icons === 'string' && this.link.getParams().icons.length)
            this.link.setParams({ icons: `${this.link.getParams().icons},${key}:${value}` });
        else
            this.link.setParams({ icons: `${key}:${value}` });
    }
    /**
     * Using this method you can set hidden elements inside widget
     *
     * @example
     * widget.setHiddenElements(['submit_button', 'email']);
     *
     * @param {string[]} elements -  list of element which can be hidden [ELEMENT]{@link ELEMENT} || [FORM_FIELD]{@link FORM_FIELD}
     */
    setHiddenElements(elements) {
        let filteredElements = [];
        let supportedElements = ObjectHelper.values(ELEMENT).concat(ObjectHelper.values(FORM_FIELD));
        for (let index in elements) {
            if (!elements.hasOwnProperty(index))
                continue;
            if (supportedElements.indexOf(elements[index]) !== -1)
                filteredElements.push(elements[index]);
            else
                console.warn(`Widget::setHiddenElements: unsupported element ${elements[index]}`);
        }
        if (filteredElements.length)
            this.link.concatParams({ hidden_elements: filteredElements.join(',') });
    }
    /**
     * Current method can set custom ID to identify the data in the future
     *
     * @example
     * widget.setRefId('id');
     *
     * @param {string} refId - custom id
     */
    setRefId(refId) {
        this.link.setParams({ ref_id: refId });
    }
    /**
     * Current method can add visual validation from gateway to widget's form fields
     *
     * @example
     * widget.useGatewayFieldValidation();
     */
    useGatewayFieldValidation() {
        this.link.setParams({ fields_validation: true });
    }
    /**
     * Current method can set icons of supported card types
     *
     * @example
     *
     * widget.setSupportedCardIcons(['mastercard', 'visa'], validateCardNumberInput);
     *
     * @param {string[]} elements - [SUPPORTED_CARD_TYPES]{@link SUPPORTED_CARD_TYPES}
     * @param {boolean} validateCardNumberInput - [validateCardNumberInput=false] - using this param you allow validation for card number input on supported card types
     */
    setSupportedCardIcons(elements, validateCardNumberInput) {
        let supportedCards = [];
        for (let index in elements) {
            if (!elements.hasOwnProperty(index))
                continue;
            if (ObjectHelper.values(SUPPORTED_CARD_TYPES).indexOf(elements[index]) !== -1)
                supportedCards.push(elements[index]);
            else
                console.warn(`Widget::cardTypes: unsupported type of cards ${elements[index]}`);
        }
        if (supportedCards.length)
            this.link.concatParams({ supported_card_types: supportedCards.join(',') });
        if (validateCardNumberInput)
            this.link.setParams({ validate_card_types: validateCardNumberInput });
    }
    /**
     * Current method can change environment. By default environment = sandbox.
     * Also we can change domain alias for this environment. By default domain_alias = paydock.com
     *
     * @example
     * widget.setEnv('production', 'paydock.com');
     * @param {string} env - sandbox, production
     * @param {string} [alias] - Own domain alias
     */
    setEnv(env, alias) {
        this.link.setEnv(env, alias);
        for (let index in this.configs) {
            if (this.configs.hasOwnProperty(index))
                this.configs[index].setEnv(env, alias);
        }
    }
    getEnv() {
        this.link.getEnv();
    }
    /**
     * Method for creating iframe url
     *
     * @example
     * widget.loadIFrameUrl(function (url) {
     *      console.log(url);
     * }, function (errors) {
     *      console.log(errors);
     * });
     */
    loadIFrameUrl(cb, errorCb = (errors) => { }) {
        this.link.setParams({ configuration_tokens: '' });
        if (this.configTokens.length) {
            this.link.setParams({ configuration_tokens: this.configTokens.join(',') });
            return cb(this.link.getUrl());
        }
        Configuration.createEachToken(this.publicKey, this.configs, (tokens) => {
            this.link.concatParams({ configuration_tokens: tokens.join(',') });
            return cb(this.link.getUrl());
        }, (errors) => {
            errorCb(errors);
        });
    }
    /**
     * Method for setting a custom language code
     *
     * @example
     * config.setLanguage('en');
     * @param {string} code - ISO 639-1
     */
    setLanguage(code) {
        this.link.setParams({ language: code });
    }
}
//# sourceMappingURL=../../src/lib/widget/multi-widget.js.map